---
title: "BioTime"
author: "Kari Norman"
date: "4/1/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(here)
library(tidyverse)
library(lazyeval)
library(rdataretriever)

```

Import occurence data from Biotime
```{r}
#rdataretriever::install("biotime", connection = "csv", data_dir = here("data"))

data <- read_csv(here("data", "biotime_metadata.csv")) %>% filter(taxa %in% c("Birds", "Mammals")) %>%
  select(study_id, taxa) %>%
  left_join(read_csv(here("data", "biotime_query.csv")), by = "study_id")
  
```

Get mammal and trait data
```{r}
bird_trait <- read_csv(here("data/elton_traits/elton_traits_BirdFuncDat.csv"))
mamm_trait <- read.csv(here("data/elton_traits/elton_traits_MammFuncDat.csv"))
```

Check which authority would result in the most matches 
```{r}
library(taxadb)

get_match_counts <- function(data, species_col){
  species_col <- lazyeval::as_name(species_col)
  data %>% 
    select(!!species_col) %>% 
    drop_na() %>%
    distinct() %>%
    mutate(
      gbif = get_ids(!!species_col, "gbif"),
      col = get_ids(!!species_col, "col" ),
      itis = get_ids(!!species_col, "itis"),
      ncbi = get_ids(!!species_col, "ncbi"),
      wd = get_ids(!!species_col, "wd"  ),
      iucn = get_ids(!!species_col, "iucn"),
      ott = get_ids(!!species_col, "ott" ) 
    ) %>%
    #select(!!call("-", species_col)) %>%
    purrr::map_dbl(function(x) sum(!is.na(x)))
}

##Counts show that OTT is the best authority for both data sets
get_match_counts(data %>% filter(taxa == "Birds"), "genus_species")
get_match_counts(data, "genus_species")
get_match_counts(bird_trait, "scientific")
get_match_counts(mamm_trait, "scientific")
```

OTT is the best authority but doesn't have common names, so we use the next best ITIS. We'll start with BioTime data:

##Biotime

```{r}
#Getting matches by scientific name 
biotime <- data %>% 
  #filter(taxa == "Birds") %>%
  select(genus_species) %>%
  drop_na() %>%
  distinct() %>%
  mutate(id = get_ids(genus_species, "itis")) %>%
  left_join(data, by = "genus_species")

#Getting matches by sci name and common name 
biotime_ids <- by_name(unique(data$genus_species), "itis") %>%
  bind_rows(by_common(unique(data$genus_species), "itis")) %>%
  #filter(taxonRank == "species") %>% #only want ID's to species, since that's the level of the trait data
  drop_na(acceptedNameUsageID)
```

Some names match to multiple acceptedUsage ID's, so we have to manually choose which one we want. In this case it's just the Blue-winged warbler
```{r}

get_dupe_ids <- function(data, orig_id){
  orig_id <- lazyeval::as_name(orig_id)
  
  data %>%
    distinct(acceptedNameUsageID, input, !!orig_id) %>%
    group_by(!!orig_id) %>% 
    filter(n()>1) %>% 
    ungroup()
}  

unres <- get_dupe_ids(biotime_ids, "sort")
unres 
```

Add the unresolved ID to all the other ids and join with biotime data
```{r}
biotime_ids <- unres %>%
left_join(biotime_ids) %>% #join ID's back with all the columns
  filter(taxonomicStatus == "accepted") %>% #want the accepted ID from the two Warbler options
  bind_rows(biotime_ids %>% filter(!sort %in% unres$sort)) #join to resolved ID's, excluding the observations we resolved manually

biotime_data <- biotime_ids %>%
  select(id = acceptedNameUsageID,input, scientificName) %>%
  distinct() %>%
  right_join(data %>% select(-species, -genus), by = c("input" = "genus_species")) %>%
  rename(matchingName = input)
```

Do any unmatched species have matches with other providers?
```{r}
#get_match_counts(biotime_data %>% filter(is.na(id)), "matchingName")

unmatched <- biotime_data %>% filter(is.na(id)) %>% pull(matchingName) %>% unique()
providers <- c("ott", "gbif", "col", "ncbi", "wd", "iucn")

#match all the un-ID'd names to other providers, check if synonyms given by those providers match known ITIS species 
alt_names <- map_df(providers, function(name) synonyms(unmatched, name)) %>%
  drop_na(acceptedNameUsageID) %>%
  #new matches can be in either the synonym or acceptedNameUsage column, so let's combine them
  gather(type, altProviderName, synonym, acceptedNameUsage) %>%
  select(altProviderName, input) %>% 
  distinct()

#match accepted names from 
syn_res <- by_name(na.omit(unique(alt_names$altProviderName)),"itis") %>%
  drop_na(acceptedNameUsageID) %>% 
  rename(altProviderName = input) %>%
  left_join(alt_names, na_matches = "never")

#some names have multiple matches (same ID but multiple scinames), have to pick one
## in this case all the duplicates have an accepted and a synonym, but there are some single matches that are just synonyms
## so we have to find duplicate ID's and then filter
alt_dupes <- syn_res %>% 
  group_by(input) %>%
  filter(n() > 1)

#filter duplicates for accepted, and replace old entries 
syn_res <- alt_dupes %>% 
  filter(taxonRank == "species", taxonomicStatus == "accepted") %>% 
  bind_rows(syn_res %>% 
              filter(!acceptedNameUsageID %in% alt_dupes$acceptedNameUsageID)) %>%
#then finish clean up 
  select(id = acceptedNameUsageID, input, scientificName) %>% 
  distinct() %>%
  left_join(data %>% select(-species, -genus), by = c("input" = "genus_species"), na_matches =  "never") %>%
  rename(matchingName = input) %>%
  ungroup()

#Below add's more rows, should just replace them 
biotime_data <- biotime_data %>% filter(!matchingName %in% syn_res$matchingName) %>%
  bind_rows(syn_res)

```


##Elton Traits
Get id's for the Elton Bird trait data

```{r}
get_trait_ids <- function(data, provider, id, common = TRUE){
  #id <- lazyeval::as_name(id)
  sci_match <-  by_name(unique(data$scientific), provider) %>%
    drop_na(acceptedNameUsageID) %>%
    #get original specid so we can figure out ho w many don't have matches
    left_join(data %>% select_(id, "scientific"), by = c("input" = "scientific")) %>%
    mutate(match_type = "scientific")
  
  if(common){
    com_names <- data %>% 
      #the id argument should be inplace of specid, but it doesn't work for some reason
      filter(!specid %in% sci_match$specid) %>%
      pull(english) %>%
      unique() %>%
      by_common("itis") %>%
      #mutate(match_type = "common")
      #filter(taxonRank == "species") %>% #only want ID's to species, since that's the level of the trait data
      drop_na(acceptedNameUsageID) %>%
      left_join(bird_trait %>% select_(id, "english"), by = c("input" = "english"))%>%
      mutate(match_type = "common")
    
    #there are both sci and common names, only want common name 
    return(bind_rows(sci_match, com_names))
  }else{ return(sci_match)}
}

bird_ids <- get_trait_ids(bird_trait, "itis", "specid")
mammal_ids <- get_trait_ids(mamm_trait, "itis", "msw3_id", FALSE)

```


Are there any unresolved ids for birds? Yes - just one, which is a synonym to two different accepted id's
```{r}
unres_trait <- get_dupe_ids(bird_ids, "specid") %>%
  left_join(bird_ids)

unres_trait

#resolve to the desired ID (in this case the one with complete hierarchy data)
bird_ids <- unres_trait %>% 
  filter(!is.na(kingdom)) %>%
  bind_rows(bird_ids %>% filter(!sort %in% unres_trait$sort))
```

What about for mammals? Yes - also a synonym to two different accepted id's. Further research shows that the Callospermophilus saturatus uses the subgenus, so we'll keep the name with the genus 
```{r}
unres_mamm_trait <- get_dupe_ids(mammal_ids, "msw3_id") %>% 
  left_join(mammal_ids)

unres_mamm_trait

mammal_ids <- unres_mamm_trait %>% 
  filter(acceptedNameUsageID == "ITIS:632452") %>%
  bind_rows(mammal_ids %>% filter(!sort %in% unres_mamm_trait$sort))
```

Join bird ids back to original trait data
```{r}
#only want one column for old name and one column for new name, these are the old ID columns to remove
col_ex <- c("passnonpass", "iocorder", "blfamilylatin", "blfamilyenglish", "blfamsequid", "taxo")

#join on scientific and common
sci_matches <- bird_ids  %>%
  filter(match_type == "scientific") %>%
  select(id = acceptedNameUsageID, input, scientificName) %>%
  distinct() %>%
  right_join(bird_trait %>% select(.dots = -col_ex), by = c("input" = "scientific"), na_matches = "never") %>%
  drop_na(id) %>%
  distinct() %>%
  select(-english)

comm_matches <- bird_ids  %>%
  filter(match_type == "common") %>%
  select(id = acceptedNameUsageID, input, scientificName) %>%
  distinct() %>%
  right_join(bird_trait %>% filter(!specid %in% sci_matches$specid) %>% select(.dots = -col_ex), by = c("input" = "english"), na_matches = "never") %>%
  distinct() %>%
  rename(matchingName = input) %>%
  select(-scientific)

#there are more rows after ID data is joined because for species that matched on common names there may be more than one scientificName 
bird_trait_data <- bind_rows(sci_matches, comm_matches)
```

Do the same for mammal trait data
```{r}
mamm_trait_data <- mammal_ids %>%
  select(id = acceptedNameUsageID, input, scientificName) %>%
  right_join(mamm_trait %>% select(-mswfamilylatin), by = c("input" = "scientific"), na_matches = "never") %>%
  drop_na(id) %>%
  distinct() 
```


#Checking Coverage of ID's and trait data -> biotime

check if all bird & mammal biotime data w/id's has an elton match. There are 258 species without a match (38 are birds).
```{r}
biotime_data %>%
  #filter(taxa == "Birds") %>%
  select(id) %>%
  distinct() %>%
  filter(!id %in% bird_trait_data$id) %>%
  dim()
```

and 605 bird species without an ID, 657 total species
```{r}
biotime_data %>%
  #filter(taxa == "Birds") %>%
  select(id, matchingName) %>%
  distinct() %>%
  filter(is.na(id)) %>%
  dim()
```

Are there any studies for which we have trait data for all species?
```{r}
#join trait and biotime data
bird_data <- biotime_data %>%
  #filter(taxa == "Birds") %>%
  left_join(bird_trait_data, by = "id",
            na_matches = "never")

coverage <- bird_data %>%
  group_by(study_id) %>%
  summarise(perc = sum(!is.na(specid))/n()) %>%
  arrange(desc(perc))

head(coverage)
```

