---
title: "BioTime"
author: "Kari Norman"
date: "4/1/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(here)
library(tidyverse)
library(lazyeval)
library(taxadb)

source(here::here("data-raw", "helper_functions.R"))
```

Import occurence data from Biotime
```{r}
#rdataretriever::install("biotime", connection = "csv", data_dir = here("data"))
# 
# data <- read.csv(system.file("extdata", "biotime/biotime_metadata.csv", package = "biodivTS")) %>%
#   select(study_id, taxa) %>%
#   left_join(read.csv(system.file("extdata", "biotime/biotime_query.csv", package = "biodivTS")), by = "study_id")

data <- pins::pin_get("year-biotime", board = "github")
```

Many of the studies with only one plot have NA for the plot number, but we want to distinguish between NA's in studies that have multiple plots and unlabled studies.
```{r}
#find studies that only have one plot labeled NA
sing_study <- data %>% 
  select(study_id, plot) %>%
  distinct() %>%
  count(study_id) %>%
  filter(n == 1) %>%
  pull(study_id)

#replace plot NA's that are really studies with only one plot with a plot label 
data <- data %>% 
  mutate(plot = case_when(
    study_id %in% sing_study & plot %in% c(NA, "", "#REF!") ~ "A",
    TRUE ~ plot
  ))
```

Check which authority would result in the most matches 
```{r}
##Counts show that OTT is the best authority 
get_match_counts(data %>% filter(taxa == "Birds"), "genus_species")
get_match_counts(data, "genus_species")
```

OTT is the best authority but doesn't have common names, so we use the next best ITIS. We'll start with BioTime data:

##Biotime

```{r}
# #Getting matches by scientific name 
# biotime <- data %>% 
#   select(genus_species) %>%
#   drop_na() %>%
#   distinct() %>%
#   mutate(id = get_ids(genus_species, "itis")) %>%
#   left_join(data, by = "genus_species")

#Getting matches by sci name and common name 
biotime_ids <- filter_name(unique(data$genus_species), "itis") %>%
  bind_rows(filter_common(unique(data$genus_species), "itis")) %>%
  filter(taxonRank == "species") %>% #only want ID's to species, since that's the level of the trait data
  drop_na(acceptedNameUsageID)
```

Some names match to multiple acceptedUsage ID's, so we have to manually choose which one we want.
```{r}
unres <- get_dupe_ids(biotime_ids, "sort")
unres 
```

Add the unresolved ID to all the other ids and join with biotime data
```{r}
biotime_ids <- unres %>%
  left_join(biotime_ids) %>% #join ID's back with all the columns
  filter(acceptedNameUsageID %in% c(
    "ITIS:1026896", #accepted on the ITIS website
    "ITIS:172921",
    "ITIS:683209",
    "ITIS:527684",
    "ITIS:782604",
    "ITIS:28107",
    "ITIS:508923",
    "ITIS:159807", #Heterodontus zebra, all the studies including it are using sci names, so we should match to the sci name match not common name match
    "ITIS:175125" #The Redhead is coming from bird studies, so choose the bird match, 
    #the rest can't be match due to too little information
  )) %>%
  bind_rows(biotime_ids %>% filter(!sort %in% unres$sort)) #join to resolved ID's, excluding the observations we resolved manually

biotime_data <- biotime_ids %>%
  select(id = acceptedNameUsageID,input, scientificName) %>%
  distinct() %>%
  right_join(data, by = c("input" = "genus_species")) %>%
  rename(sourceName = input)
```

Some ID's matched to more than one species in biotime, so we need to consolidate those entries so there is only one per ID (by removing the sourceName) 
```{r}
#find the entries for species that match to the same ID as another species
dupe_id_entry <- biotime_data %>% 
  group_by(id) %>% 
  filter(n_distinct(sourceName) > 1) 

biotime_data <- setdiff(biotime_data, dupe_id_entry) %>%
  bind_rows(dupe_id_entry %>% 
              select(-sourceName, id_species) %>% 
              group_by(id, scientificName, plot, year, study_id, taxa) %>% 
              summarize(year_abun = sum(year_abun), year_biomass = sum(year_biomass)))
```

Do any unmatched species have matches with other providers?

NOT EXECUTED FOR CURRENT ITERATION (9/4/20)
```{r}
# 
# #Check for potential matches from synonyms found in the other providers
# syn_res <- match_providers(biotime_data, "itis", common = TRUE)
# 
# #some names have multiple matches (same ID but multiple scinames), have to pick one
# ## in this case all the duplicates have an accepted and a synonym, but there are some single matches that are just synonyms
# ## so we have to find duplicate ID's and then filter
# alt_dupes <- syn_res %>%
#   select(acceptedNameUsageID, input) %>%
#   distinct() %>%
#   group_by(input) %>%
#   filter(n() > 1)
# 
# # #filter duplicates for accepted, and replace old entries 
# # syn_res <- alt_dupes %>% 
# #   filter(acceptedNameUsageID %in% c(
# #     ITIS:331277, 
# #   )) %>% 
# #   bind_rows(syn_res %>% 
# #               filter(!acceptedNameUsageID %in% alt_dupes$acceptedNameUsageID)) %>%
# # #then finish clean up 
# #   select(id = acceptedNameUsageID, input, scientificName) %>% 
# #   distinct() %>%
# #   left_join(data %>% select(-species, -genus), by = c("input" = "genus_species"), na_matches =  "never") %>%
# #   rename(sourceName = input) %>%
# #   ungroup()
# 
# #Just get rid of those with duplicates, deal with them later
# add_syn_res <- syn_res %>% 
#   filter(!input %in% alt_dupes$input) %>% #excluding duplicate matched species
#   select(id = acceptedNameUsageID, sourceName = input, scientificName) %>%
#   distinct() %>%
#   group_by(sourceName) %>%
#   top_n(1, scientificName) %>% #some have multiple sci names for same id, just pick on 
#   left_join(biotime_data%>% select(-c(id, scientificName)), by = "sourceName", na_matches =  "never") %>%
#   ungroup() %>%
#   distinct()
# 
# biotime_data <- biotime_data %>% 
#   filter(!sourceName %in% add_syn_res$sourceName) %>%
#   bind_rows(add_syn_res)

```

```{r}
usethis::use_data(biotime_data)
```

