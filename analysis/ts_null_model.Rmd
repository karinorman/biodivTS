---
title: "null_model"
author: "Kari Norman"
date: "6/2/2020"
output: html_document
---

```{r}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
```

Create null models that would be transferable to any timeseries by treating the species pool as all species observed across the timeseries.

Simulation functions
```{r}
load(here::here("data", "biotime_traits.rda"))

get_plot_sample <- function(data, study, plot_id, n){
  rich_levels <- data %>%
    filter(study_id == study, plot == plot_id) %>%
    select(year, id) %>%
    distinct() %>%
    count(year) %>%
    pull(n) %>%
    unique()
  
  species_pool <- data %>% 
    filter(study_id == study, plot == plot_id) %>%
    pull(id) %>%
    na.omit() %>%
    unique() #get column of unique scientific names
  
  get_samp_species <- function(richness){
    samp_species <- sample(species_pool, richness)
    df <- cbind(richness, samp_species)
    return(df)
  }
  
  site_samples <- data.frame()
  for (j in 1:n){
    iter_samples <- data.frame()
    for(i in rich_levels){
    iter_samples <- rbind(iter_samples, get_samp_species(i))
    }
    site_samples <- rbind(site_samples, iter_samples %>% mutate(n = j))
  }
  site_samples %>%
    mutate(study_id = study, plot = plot_id, value = 1) %>%
    pivot_wider(names_from = samp_species, values_from = value, values_fill = list(value = 0))
}

#drop trait columns that are the same value for every observation, and therefore providing no additional info
clean_trait_matrix <- function(trait_matrix){
  uniq_vals <- sapply(trait_matrix, function(x){length(unique(x))}) #get number of unique values of each trait
  col_names <- names(which(uniq_vals == 1)) #find columns where there is only one value for all observations
  return(select(trait_matrix, -col_names))
}

get_trait_matrix <- function(species_list, trait_list){ 
  traits <- biotime_traits %>%
    filter(id %in% species_list) %>%
    dplyr::select(id, all_of(trait_list)) %>%
    distinct() %>%
    arrange(id) %>%
    column_to_rownames(var = "id")
}
```

Get dataframe of samples for each plot and corresponding species and trait matrices
```{r}
n = 100

plots <- biotime_traits %>%
    select(study = study_id, plot_id = plot) %>%
    distinct()

sample_occurrence <- pmap_dfr(plots[1:10,], get_plot_sample, data = biotime_traits, n = n) %>%
  replace(is.na(.), 0)

sample_species_mat <- select(sample_occurrence, -c(richness, study_id, plot, n)) %>% #want only species x site info
  select(sort(tidyselect::peek_vars())) #sort columns to be in alphabetical order, required for dbFDI()

traits <- colnames(biotime_traits)[17:64]
sample_trait_mat <- clean_trait_matrix(get_trait_matrix(colnames(sample_species_mat), traits))
```

Explore different functional diversity approaches, starting with original FD application

```{r}
library(FD)

#get diversity metrics from FD package
sample_fd <- as.data.frame(dbFD(x = sample_trait_mat, a = sample_species_mat, w.abun = FALSE))

 #checks for merging output with richness/study info
df <- sample_occurrence %>%
  select(richness, study_id, plot, n) %>%
  bind_cols(sample_fd) %>%
  mutate(merge_test = case_when(richness == nbsp ~ TRUE,
                                TRUE ~ FALSE))

if (sum(df$merge_test) != dim(df)[1])
  warning("richness and region columns may not have been appropriately joined with FD data")
```

BAT
```{r}
library(BAT)



```

