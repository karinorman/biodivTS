---
title: "Check Coverage"
author: "Kari Norman"
date: "5/20/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(FD)
devtools::load_all()
```

```{r}
load(here::here("data", "biotime_data.rda"))
load(here::here("data", "elton_mamm.rda"))
load(here::here("data", "elton_bird.rda"))
load(here::here("data", "amphibio.rda"))
```

#Checking Coverage of ID's and trait data -> biotime

check if all bird & mammal biotime data w/id's has an elton match. There are 68 species without a match (63 are birds).
```{r}
no_trait <- biotime_data %>%
  filter(taxa %in% c("Birds", "Mammals")) %>%
  select(id, sourceName, taxa) %>%
  drop_na(id) %>%
  distinct() %>%
  filter(!id %in% elton_bird$id, !id %in% elton_mamm$id)

dim(no_trait)
```

and 19869 species without an ID, some of which are species codes
```{r}
biotime_data %>%
  #filter(taxa == "Birds") %>%
  select(id, sourceName, taxa) %>%
  filter(is.na(id)) %>%
  distinct() %>%
  dim()
```

Are there any studies for which we have trait data for all species?
```{r}
merge_data <- function(trait_data){
  biotime_data %>%
    select(-scientificName) %>%
    rename(biotimeName = sourceName) %>%
  left_join(trait_data %>% rename(traitName = sourceName), by = "id",
            na_matches = "never") #%>%
   # drop_na(scientificName)
}
```

Get data w/traits for all studies that have >85% trait coverage

`id` is `NA` if there was no `id` match
`biotimeName` or `traitName` is `NA` if that ID is the result of an average of multliple species matches
`scientificName` is `NA` when there was no trait data for a given ID
```{r}
#set coverage threshold for analysis dataset
percent <- 0.85

traits <- list(elton_bird, elton_mamm, amphibio)

comp_biotime_traits <- map_dfr(traits, merge_data) %>%
  right_join(biotime_data %>% select(-sourceName, -scientificName))

#always check that one species didn't match to multiple datasets, below should return and empty dataframe
#comp_biotime_traits %>% group_by(record_id) %>% filter(n() > 1) %>% dim()

#this gives a coverage for each trait dataset, so potentially a lot of coverage with one dataset and no coverage on all the rest
#need to get rid of zeros when there is coverage from another dataset so we only have one entry per study
coverage <- comp_biotime_traits %>%
  select(study_id, scientificName) %>%
  distinct() %>%
  group_by(study_id) %>%
  summarise(perc = sum(!is.na(scientificName))/n()) %>%
  arrange(desc(perc))

inc_coverage <- coverage %>% filter(perc > percent)

biotime_traits <- comp_biotime_traits %>%
  #get studies with appropriate coverage and drop observations that we don't have trait data for
  filter(study_id %in% inc_coverage$study_id, !is.na(scientificName)) %>% 
  mutate(plot_id = paste0(study_id, plot))
```

```{r}
usethis::use_data(biotime_traits)
```


Create table of info for each study
```{r}
study_table <- biotime_data %>%
  group_by(study_id) %>%
  mutate(min_year = min(year), max_year = max(year)) %>% 
  #select(study_id, plot, taxa, latitude, longitude, min_year, max_year) %>%
  select(study_id, taxa, min_year, max_year) %>%
  distinct() %>%
  left_join(coverage %>% select(study_id, coverage = perc), by = "study_id")

usethis::use_data(study_table)
```

Get FD metrics for each study 

FD function:
```{r}
library(furrr)
load(here::here("data", "biotime_traits.rda"))

get_fd <- function(data, filter_plot){
  require(FD)
  
  data <- data %>%
    filter(plot_id == filter_plot)
  
  print(filter_plot)
  
  species_mat <- data %>%
    select(year, id) %>% 
    distinct() %>%
    arrange(year, id) %>%
    mutate(present = 1) %>%
    spread(id, value = present, fill = 0) %>%
    select(-year)
  
  years <- data %>% 
    select(year) %>%
    distinct() %>%
    arrange(year)
  
  trait_mat <- data %>%
    select(-c(taxa, record_id, day, month, year, sample_desc, id_species, 
              latitude, longitude, sum_abundance, sum_biomass, traitName, 
              biotimeName, scientificName)
    ) %>%
    distinct() %>%
    select_if(~ length(unique(.)) > 1) %>% #remove columns that have the same value for all columns
    mutate_at(vars(-id, -ends_with("5cat")), list(~scales::rescale(.,to=c(0, 1)))) %>% #rescale variables
    arrange(id) %>%
    column_to_rownames("id")
  
  fs::dir_create(paste0(here::here("data"), "/fd_output"))
  
  #the convexhull c code creates an output file of vertices, in order to not have multiple threads writing
  #to the same file we have to create individual working directories
  tmp_dir <- paste0(here::here("data", "fd_output", "tmp"), "/tmp_", filter_plot)
  fs::dir_create(tmp_dir)
  setwd(tmp_dir)

  fd_out <- as_tibble(dbFD_joggle(trait_mat, species_mat, w.abun = FALSE))[,1:8] %>%
    cbind(years, .) %>%
    mutate(plot_id = unlist(filter_plot), trait_count = dim(trait_mat)[2]) %>%
    write_tsv(paste0(here::here("data"), "/fd_output/", filter_plot, "_fd.tsv"))
  
  setwd(here::here())
  return(fd_out)
}

get_fd_safe <- possibly(get_fd, NA)
```

First pass at calculating FD metrics from FD package:
```{r}
data <- biotime_traits %>% 
  filter(!is.na(plot)) %>% #remove unlabeled plots 
  group_by(plot_id, year) %>%
  filter(n_distinct(id) > 4) %>%
  ungroup()# %>%
  #filter(!study_id %in% c(195, 360), #exclude because they break
         #!study_id %in% c(217, 327)) #exclude to get the file size smaller

plots <- data %>%
  pull(plot_id) %>%
  unique()

plan(multiprocess)
system.time(fd <- future_map_dfr(plots[1:10], get_fd, data = data))
```

Read data back in, excluding sites/plots as they become a problem:
```{r}
files <-  dir(here::here("data", "fd_output"), "*.tsv")

fd_data <- files %>%
  paste0(here::here("data", "fd_output"), "/", .) %>%
  map_dfr(read_tsv)

remain <- biotime_traits %>%
  filter(!is.na(plot), !is.na(scientificName)) %>% #remove unlabeled plots and observations without traits
  filter(!is.na(plot), !study_id %in% c(195, 360),
         !study_id %in% c(217, 327), #exclude to get the file size smaller
         !study_id %in% c(59, 166, 337), #NA's in the distance matrix
         study_id != 169,  #Zero distance error
         !study_id %in% c(372,374), #Qhull error code 4
         study_id != 333) %>% #species distance matrix not Euclidean after 'sqrt' correction
  filter(study_id != 56 | plot != 24) %>% #NA's in the distance matrix
  anti_join(fd_data, by = c("year", "study_id", "plot")) %>%
  group_by(study_id, year, plot) %>%
  filter(n_distinct(id) > 4) %>%
  ungroup()

combs <- remain %>%
  select(study_id, plot) %>%
  distinct()

plan(multiprocess)
system.time(fd <- future_pmap_dfr(combs, ~ get_fd(data = remain, study = .x, plot = .y)))
```

Let's also do the functions from BAT package
```{r}
#function for getting PCA axes with at least 95% coverage
axes95 <- function(mat){
  axes <- pco(mat)
  eigen <- axes$eig
  
  threshold <- sum(eigen[eigen > 0]) * 0.95
  
  sums <- cumsum(eigen)
  num_axes <- Position(function(x) x > threshold, sums)
  
  return(num_axes)
}

get_BAT_fd <- function(data, filter_plot){
  require(BAT)
  require(StatMatch)
  require(labdsv)
  
  data <- data %>% filter(plot_id == filter_plot)
  
  print(max(data$record_id))
  
  species_mat <- data %>%
    select(year, id) %>% 
    distinct() %>%
    arrange(year, id) %>%
    mutate(present = 1) %>%
    spread(id, value = present, fill = 0) %>%
    column_to_rownames("year")
  
  trait_mat <- data %>%
    select(-c(taxa, record_id, day, month, year, sample_desc, id_species, 
              latitude, longitude, sum_abundance, sum_biomass, biotimeName, 
              traitName, scientificName)
    ) %>%
    distinct() %>%
    select_if(~ length(unique(.)) > 1) %>% #remove columns that have the same value for all columns
    mutate_at(vars(-id, -ends_with("5cat")), list(~scales::rescale(.,to=c(0, 1)))) %>% #rescale variables
    arrange(id) %>%
    column_to_rownames("id")
  
  #get PCA trait matrix
  trait_dist <- gower.dist(trait_mat)
  trait_pco <- pco(trait_dist, k = axes95(trait_dist))
  
  traits <- trait_pco$points
  rownames(traits) <- rownames(trait_mat)
  
  #getFD metrics
  kernelFD <- kernel.alpha(comm=as.matrix(species_mat),trait=traits,abund=FALSE,method="gaussian",return.hv=TRUE)
  hv <- kernelFD[[2]]
  
  disp <- kernel.dispersion(comm=hv,frac=0.1,func='dissimilarity') 
  div <- kernel.dispersion(comm=hv,frac=0.6, func='divergence')
  even <- kernel.evenness(comm=hv)
  
  results <- data.frame(richness = as.numeric(kernelFD[[1]]), disp, div, even) %>% 
    mutate(plot_id = filter_plot)
  
  return(results)
}

get_BAT_fd(biotime_traits, 376300153)
```


Format tables
```{r}
fd_table <- fd_data %>% 
  select(year, study_id, plot, richness = nbsp, everything(), -sing.sp) %>%
  gather(metric, value, contains("F"), RaoQ)

usethis::use_data(fd_table)
```

#Correct FD for species richness

First for one study, 311
```{r}

glm_correction <- function(study, plot_num){
  model_data <- fd_table %>% filter(metric == "FRic", study_id == study, plot == plot_num)
  fit <- glm(value ~ richness, data = model_data)
  
  pred_vars <- model_data %>% 
    select(richness) %>% 
    distinct() %>%
    mutate(fric_pred = predict(fit, ., type = "response"))
  
  plot_data <- left_join(model_data, pred_vars) %>%
    mutate(fric_adj = value - fric_pred,
           fric_adj = ifelse(fric_adj > 0, fric_adj, 0))
  
  return(plot_data)
}

plot_data <- glm_correction(311, 1)

plot_data %>%
  ggplot() +
  geom_line(aes(x = year, y = value), color = "blue") +
  geom_line(aes(x = year, y = fric_pred), color = "red") +
  geom_line(aes(x = year, y = fric_adj), color = "black") +
  scale_x_continuous(breaks = scales::pretty_breaks()) +
  theme(legend.position = "none") +
  ylab("Fric")
```

